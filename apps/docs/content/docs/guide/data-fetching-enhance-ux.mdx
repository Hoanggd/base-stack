---
title: Enhancing User Experience
description: Practical tips for improving the user experience during data fetching in React apps.
---

> Perceived performance, in the end, is the only performance that truly matters. If what we make doesn't feel fast, then no amount of optimization counts.

## Understanding App Performance

When we talk about performance, there are two types: **actual performance** and **perceived performance**.

- **Actual performance** is what you can measure - numbers from tools like Lighthouse.
- **Perceived performance** is how fast your app **feels** to users.

Your app might score 98 on Lighthouse, but if users still think it’s slow, that number doesn’t mean much.

Here are some simple ways to make your web app feel faster, even if it’s not truly faster.

## Visibility of System Status

Never leave users guessing. Always show feedback when something is happening, like a loading bar for uploads,
a spinner for data fetching, or a button state change for form submissions. This tells users the app is working,
keeps them informed, and prevents frustrated repeat clicks. The feedback should appear within 1
second for any action that takes time to complete.

In **React Query**, there are three loading states (`isLoading`, `isFetching`, `isPending`), the best practice is to handle them differently:

### 1. `isLoading`
`isLoading` becomes `true` when the query runs for the very first time, like after the app initially mounts or on a full page reload.
This is the ideal moment to display a global `<Spinner/>` or `<Skeleton/>` to communicate to users that the main content is loading for the first time.

```tsx
const postQuery = useQuery(api.post.detail(postId))
const post = postQuery.data?.data

if (postQuery.isLoading) {
    return <Spinner />
}

if (postQuery.isError) {
    return <Error />
}

return (
    <div className="space-y-4">
        <h1 className="text-3xl font-bold">{post?.title}</h1>
        <p>{post?.content}</p>
    </div>
)
```

### 2. `isFetching`
`isFetching` is `true` any time a query is actively refreshing in the background, 
such as after changing filters, pagination, or refetching. 
Use this state to show lightweight progress indicators (`NProgress`) 
while keeping existing data visible, ensuring the UI doesn't flicker or shift.
Example:
```tsx
const [search] = useQueryState('search', parseAsString.withDefault(''))

const postsQuery = useQuery({
    queryKey: [posts, 'list', q],
    queryFn: ({ signal }) => {
        return this.client.get('/post', { params: { q }, signal })
    },
    placeholderData: keepPreviousData,
})

useNProgress({ isFetching: postsQuery.isFetching })

// render
```
Additionally, when fetching lists, keep in mind:
- Set `placeholderData: keepPreviousData` in the query options to avoid layout shift.
- Because list screens often include search and filters, the `queryKey` changes frequently, which can trigger many requests. Pass the abort `signal` so the query can cancel unnecessary requests.

See another real-world example of how `isFetching` is used <Link href="/docs/ui/data-table#real-world-example">here</Link>.

### 3. `isPending`
`isPending` is `true` when a mutation (like a form submit or data update) is running. 
Use this to provide UI feedback during user-triggered actions, 
such as disabling submit buttons or showing a loading spinner, so users know something is happening.

1) If the action is a single button, disable that button, for example:
```tsx
const exportMutation = useMutation({ mutationFn })

<Button isDisabled={exportMutation.isPending}>Export<Button>
```

2) For form submissions, wrap the entire form with `LoadingOverlay`, for example:
<ComponentPreview name="RecFormWithLoading" className="max-w-[350px] mx-auto" />

## Use Optimistic UI

When a user clicks a button, show a result right away instead of waiting for the server.
Update the screen first, then sync with the server in the background.
Even if your API is slow, this makes the app feel fast.

## Avoid Layout Shifts

Don’t let elements jump around while the page is loading.
Set image sizes, reserve space for ads, and load fonts properly.
A stable layout feels smoother and more reliable.

## Final Thought: Fast Is a Feeling

Performance isn’t just about numbers, it’s about how your app makes users feel.
People won’t remember that your page loaded in 1.2 seconds, but they’ll remember that it felt easy and smooth to use.
